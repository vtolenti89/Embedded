{"version":3,"sources":["services/api-service.jsx","services/garden-service.jsx","components/water-container.jsx","App.jsx","serviceWorker.jsx","index.jsx"],"names":["url","localhost","gardenService","getStatus","http","get","setWaterLevel","waterLevel","put","endpoint","values","JSON","parse","localStorage","getItem","Promise","resolve","reject","fetch","method","headers","Accept","Content-Type","Access-Control-Allow-Origin","x-access-token","user","token","then","response","ok","json","status","window","location","replace","data","catch","error","console","log","body","stringify","options","WaterContainer","props","waterStyle","height","concat","react_default","a","createElement","className","style","bottom","connectionOptions","force new connection","reconnectionAttempts","timeout","transports","App","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","getGardenStatus","asyncToGenerator","regenerator_default","mark","_callee","gardenStatus","wrap","_context","prev","next","sent","stop","_ref2","_callee2","newWaterLevel","_context2","_x","apply","arguments","state","bind","assertThisInitialized","_this2","_this$state","socket","socketClient","on","newData","updatedData","assign","setState","emit","_this3","components_water_container","onClick","React","Component","Boolean","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c603ca88.chunk.js","sourcesContent":["const url = \"http://localhost:3001\";\r\nconst localhost = \"https://localhost:3000\";\r\n\r\nclass HttpService {\r\n\r\n  get(endpoint) {\r\n\r\n    var values = JSON.parse(localStorage.getItem(\"rootKeys\"));\r\n    return new Promise(function (resolve, reject) {\r\n      fetch(url + endpoint, {\r\n        method: 'GET',\r\n        //credentials: 'same-origin', // persistent cookies\r\n        //credentials: \"include\",\r\n        headers: {\r\n          'Accept': 'application/json',\r\n          'Content-Type': 'application/json',\r\n          'Access-Control-Allow-Origin':url,\r\n          'x-access-token': values ? values.user.token : ''\r\n        },\r\n      })\r\n        .then(response => {\r\n          if (!response.ok) {\r\n            if (response.status === 403) {\r\n              // token is not valid\r\n              window.location.replace(localhost); // TODO add the domain\r\n            }\r\n            return response;\r\n          }\r\n          return response.json();\r\n        }).then(data => {\r\n          resolve(data)\r\n          return data;\r\n        })\r\n        .catch(error => {\r\n          console.log(error);\r\n          reject(error)\r\n        });\r\n    })\r\n  };\r\n\r\n  post(endpoint, data) {\r\n    var values = JSON.parse(localStorage.getItem(\"rootKeys\"));\r\n    return new Promise(function (resolve, reject) {\r\n      fetch(url + endpoint, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Accept': 'application/json',\r\n          'Content-Type': 'application/json',\r\n          'Access-Control-Allow-Origin':url,\r\n          'x-access-token': values ? values.user.token : ''\r\n        },\r\n        body: JSON.stringify(data)\r\n      })\r\n        .then(response => {\r\n          if (!response.ok) {\r\n            if (response.status === 403) {\r\n              // token is not valid\r\n              window.location.replace(localhost); // TODO add the domain\r\n            }\r\n            return response;\r\n          }\r\n          return response.json();\r\n        }).then(data => {\r\n          resolve(data)\r\n          return data;\r\n        })\r\n        .catch(error => {\r\n          reject(error)\r\n        });\r\n    })\r\n  };\r\n\r\n  put(endpoint, data, options) {\r\n    var values = JSON.parse(localStorage.getItem(\"rootKeys\"));\r\n    return new Promise(function (resolve, reject) {\r\n      fetch( url + endpoint, {\r\n        method: 'PUT',\r\n        //credentials: 'same-origin', // persistent cookies\r\n        //credentials: \"include\",\r\n        headers: {\r\n          'Accept': 'application/json',\r\n          'Content-Type': 'application/json',\r\n          'Access-Control-Allow-Origin':url,\r\n          'x-access-token': values ? values.user.token : ''\r\n        },\r\n        body: JSON.stringify(data)\r\n      })\r\n        .then(response => {\r\n          console.log(response)\r\n          if (!response.ok) {\r\n            if (response.status === 403) {\r\n              // token is not valid\r\n              window.location.replace(localhost); // TODO add the domain\r\n            }\r\n            return response;\r\n          }\r\n          return response.json();\r\n        }).then(data => {\r\n          resolve(data)\r\n          return data;\r\n        })\r\n        .catch(error => {\r\n          reject(error)\r\n        });\r\n    })\r\n  };\r\n};\r\n\r\nexport default HttpService;","import HttpService from './api-service';\r\n\r\nexport const gardenService = {\r\n    getStatus,\r\n    setWaterLevel\r\n};\r\n\r\nconst http = new HttpService();\r\n\r\n\r\nfunction getStatus() {\r\n    return http.get('/garden');\r\n}\r\n\r\nfunction setWaterLevel(waterLevel) {\r\n    return http.put('/garden/setwaterlevel', {waterLevel: waterLevel});\r\n}","import React from 'react';\r\nimport './water-container.css';\r\n\r\nfunction WaterContainer(props) {\r\n    console.log(props);\r\n    const waterStyle = {\r\n        height: `${props.waterLevel}%`\r\n    }\r\n\r\n    const indicatorStyle = {\r\n        //bottom: `calc(${props.waterLevel}% / 2)`\r\n        bottom: `50%`\r\n    }\r\n\r\n    return (\r\n        <div className=\"water-container\">\r\n            {/* <div id=\"sea\" className=\"sea\">\r\n                <svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\r\n                    <defs>\r\n                        <pattern id=\"water\" width=\".25\" height=\"2\" patternContentUnits=\"objectBoundingBox\">\r\n                            <path fill=\"#20293F\" d=\"M0.25,1H0c0,0,0-0.659,0-0.916c0.083-0.303,0.158,0.334,0.25,0C0.25,0.327,0.25,1,0.25,0.5z\" />\r\n                        </pattern>\r\n                    </defs>\r\n                    <rect id=\"waves\" className=\"water-fill\" fill=\"url(#water)\" width=\"3000\" />\r\n                </svg>\r\n            </div> */}\r\n            <div className=\"water-container__content\" style={waterStyle} >\r\n            </div>\r\n            <div className=\"water-container__indicator\" style={indicatorStyle}>\r\n                {props.waterLevel}%\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default WaterContainer;","import React from 'react';\r\nimport socketClient from 'socket.io-client';\r\nimport './app.css';\r\nimport {gardenService} from './services/garden-service';\r\nimport WaterContainer from './components/water-container';\r\n\r\nconst connectionOptions = {\r\n  \"force new connection\": true,\r\n  \"reconnectionAttempts\": \"Infinity\",\r\n  \"timeout\": 10000,\r\n  \"transports\": [\"websocket\"] //important\r\n}\r\n\r\nclass App extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      data: {\r\n        waterLevel: 0\r\n      },\r\n      endpoint: \"http://localhost:3001\"\r\n  };\r\n\r\n    this.getGardenStatus = this.getGardenStatus.bind(this);\r\n    this.setWaterLevel = this.setWaterLevel.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const {data,endpoint} = this.state;\r\n    //Very simply connect to the socket\r\n    const socket = socketClient(endpoint,connectionOptions);\r\n    //Listen for data on the \"outgoing data\" namespace and supply a callback for what to do when we get one. In this case, we set a state variable\r\n    socket.on(\"outgoingData\", (newData) => {\r\n      console.log('outgoing data:', newData)\r\n      let updatedData = Object.assign({}, data, newData);\r\n      console.log('update:', updatedData)\r\n      this.setState({data: updatedData}, () => {console.log(this.state.data)});\r\n    });\r\n    socket.emit('incomingData', { data: 'Subscribing to channel' });\r\n  }\r\n\r\n  getGardenStatus = async () => {\r\n    let gardenStatus = await gardenService.getStatus();\r\n    console.log(gardenStatus);\r\n  }\r\n\r\n  setWaterLevel = async (waterLevel) => {\r\n    let newWaterLevel = await gardenService.setWaterLevel(waterLevel);\r\n    console.log(newWaterLevel);\r\n  } \r\n\r\n  render() {\r\n    const {data} = this.state;\r\n    return (\r\n      <div className=\"app\">\r\n        <WaterContainer waterLevel={data.waterLevel}/>\r\n        <button onClick={()=>this.setWaterLevel(50)}>Set Water</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}